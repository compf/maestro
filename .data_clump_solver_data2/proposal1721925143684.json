"{\n    \"refactorings\": {\n        \"maestro-engine/src/main/java/com/netflix/maestro/engine/handlers/WorkflowActionHandler.java\": [\n            {\n                \"fromLine\": 57,\n                \"toLine\": 103,\n                \"oldContent\": \"import lombok.extern.slf4j.Slf4j;\\n\\n/** Workflow actor to implement all workflow actions. */\\n@Slf4j\\n@AllArgsConstructor\\npublic class WorkflowActionHandler {\\n  private final MaestroWorkflowDao workflowDao;\\n  private final MaestroWorkflowInstanceDao instanceDao;\\n  private final MaestroRunStrategyDao runStrategyDao;\\n  private final DryRunValidator dryRunValidator;\\n  private final WorkflowHelper workflowHelper;\\n\\n  /**\\n   * Start a workflow instance run. It first created a workflow instance in DB and then put it in a\\n   * queue to check its run strategy. After run strategy check, the workflow instance then gets\\n   * launched.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest`, or exact version id\\n   * @param runRequest run request with start configs and overrides\\n   * @return the response\\n   */\\n  public RunResponse start(\\n      @NotNull String workflowId, @NotNull String version, @NotNull RunRequest runRequest) {\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    validateRequest(version, definition, runRequest);\\n\\n    RunProperties runProperties =\\n        RunProperties.from(\\n            Checks.notNull(\\n                definition.getPropertiesSnapshot(),\\n                \\\"property snapshot cannot be null for workflow: \\\" + workflowId));\\n    // create and initiate a new instance with overrides and param evaluation\\n    WorkflowInstance instance =\\n        workflowHelper.createWorkflowInstance(\\n            definition.getWorkflow(),\\n            definition.getInternalId(),\\n            definition.getMetadata().getWorkflowVersionId(),\\n            runProperties,\\n            runRequest);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int ret = runStrategyDao.startWithRunStrategy(instance, runStrategy);\\n    RunResponse response = RunResponse.from(instance, ret);\\n    LOG.info(\\\"Created a workflow instance with response {}\\\", response);\\n    return response;\",\n                \"newContent\": \"import lombok.extern.slf4j.Slf4j;\\n\\n/** Workflow actor to implement all workflow actions. */\\n@Slf4j\\n@AllArgsConstructor\\npublic class WorkflowActionHandler {\\n  private final MaestroWorkflowDao workflowDao;\\n  private final MaestroWorkflowInstanceDao instanceDao;\\n  private final MaestroRunStrategyDao runStrategyDao;\\n  private final DryRunValidator dryRunValidator;\\n  private final WorkflowHelper workflowHelper;\\n\\n  /**\\n   * Start a workflow instance run. It first created a workflow instance in DB and then put it in a\\n   * queue to check its run strategy. After run strategy check, the workflow instance then gets\\n   * launched.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest’, or exact version id\\n   * @param runRequest run request with start configs and overrides\\n   * @return the response\\n   */\\n  public RunResponse start(\\n      @NotNull String workflowId, @NotNull String version, @NotNull RunRequest runRequest) {\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    validateRequest(version, definition, runRequest);\\n\\n    RunProperties runProperties =\\n        RunProperties.from(\\n            Checks.notNull(\\n                definition.getPropertiesSnapshot(),\\n                \\\"property snapshot cannot be null for workflow: \\\" + workflowId));\\n    // create and initiate a new instance with overrides and param evaluation\\n    WorkflowInstance instance =\\n        workflowHelper.createWorkflowInstance(\\n            new WorkflowInstanceCreationContext(\\n                definition.getWorkflow(),\\n                definition.getInternalId(),\\n                definition.getMetadata().getWorkflowVersionId(),\\n                runProperties),\\n            runRequest);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int ret = runStrategyDao.startWithRunStrategy(instance, runStrategy);\\n    RunResponse response = RunResponse.from(instance, ret);\\n    LOG.info(\\\"Created a workflow instance with response {}\\\", response);\\n    return response;\"\n            },\n            {\n                \"fromLine\": 129,\n                \"toLine\": 157,\n                \"oldContent\": \"\\n  /**\\n   * Start a batch of new workflow instance runs (i.e. with run_id = 1) asynchronous. It first\\n   * created workflow instances in DB and then send a job event to run strategy poller, which checks\\n   * and start queued workflow instances if possible. Note that request list size must fit into a\\n   * single DB transaction batch limit defined by {@link Constants#START_BATCH_LIMIT}. It will\\n   * handle the case with duplicate uuids.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest’, or exact version id\\n   * @param requests a list of start requests with start configs and overrides\\n   * @return the response\\n   */\\n  public List<RunResponse> startBatch(\\n      String workflowId, String version, List<RunRequest> requests) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Collections.emptyList();\\n    }\\n    Checks.checkTrue(\\n        requests.size() <= Constants.START_BATCH_LIMIT,\\n        \\\"The size of Requests is greater than the batch limit\\\");\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    // Fail the whole batch if any request is invalid\\n    requests.forEach(request -> validateRequest(version, definition, request));\\n\\n    RunProperties runProperties = RunProperties.from(definition.getPropertiesSnapshot());\\n\",\n                \"newContent\": \"\\n  /**\\n   * Start a batch of new workflow instance runs (i.e. with run_id = 1) asynchronous. It first\\n   * created workflow instances in DB and then send a job event to run strategy poller, which checks\\n   * and start queued workflow instances if possible. Note that request list size must fit into a\\n   * single DB transaction batch limit defined by {@link Constants#START_BATCH_LIMIT}. It will\\n   * handle the case with duplicate uuids.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest’, or exact version id\\n   * @param requests a list of start requests with start configs and overrides\\n   * @return the response\\n   */\\n  public List<RunResponse> startBatch(\\n      String workflowId, String version, List<RunRequest> requests) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Collections.emptyList();\\n    }\\n    Checks.checkTrue(\\n        requests.size() <= Constants.START_BATCH_LIMIT,\\n        \\\"The size of Requests is greater than the batch limit\\\");\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    // Fail the whole batch if any request is invalid\\n    requests.forEach(request -> validateRequest(version, definition, request));\\n\\n    RunProperties runProperties = RunProperties.from(definition.getPropertiesSnapshot());\\n\"\n            },\n            {\n                \"fromLine\": 160,\n                \"toLine\": 167,\n                \"oldContent\": \"            definition.getInternalId(),\\n            definition.getMetadata().getWorkflowVersionId(),\\n            runProperties,\\n            requests);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int[] results = runStrategyDao.startBatchWithRunStrategy(workflowId, runStrategy, instances);\\n    List<RunResponse> responses = new ArrayList<>();\",\n                \"newContent\": \"            new WorkflowInstanceCreationContext(\\n                definition.getWorkflow(),\\n                definition.getInternalId(),\\n                definition.getMetadata().getWorkflowVersionId(),\\n                runProperties),\\n            requests);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int[] results = runStrategyDao.startBatchWithRunStrategy(workflowId, runStrategy, instances);\\n    List<RunResponse> responses = new ArrayList<>();\"\n            },\n            {\n                \"fromLine\": 171,\n                \"toLine\": 252,\n                \"oldContent\": \"    }\\n    LOG.debug(\\n        \\\"Created {} of workflow instances for workflow id {} to start\\\",\\n        requests.size(),\\n        workflowId);\\n    return responses;\\n  }\\n\\n  /**\\n   * Run a batch of foreach workflow instances for a given workflow and version. The request list\\n   * has already been sized by insertBatchLimit in StepRuntimeProperties.Foreach. Note that batch\\n   * start only supports a fresh new run (run_id=1). Additionally, the instance ids have already\\n   * been decided to avoid race condition and ensure idempotency. It will bypass run strategy\\n   * manager as foreach manages its own inline workflow instances.\\n   *\\n   * @param batchSize the batch size for run job instance uuids within a run job event.\\n   * @return the status of start foreach workflow instances.\\n   */\\n  public Optional<Details> runForeachBatch(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds,\\n      int batchSize) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Optional.empty();\\n    }\\n    Checks.checkTrue(\\n        requests.size() == instanceIds.size(),\\n        \\\"Run request list size [%s] must match instance id list size [%s]\\\",\\n        requests.size(),\\n        instanceIds.size());\\n    List<WorkflowInstance> instances;\\n    if (artifact.isFreshRun()) {\\n      instances =\\n          createStartForeachInstances(\\n              workflow,\\n              internalId,\\n              workflowVersionId,\\n              artifact.getForeachRunId(),\\n              runProperties,\\n              requests,\\n              instanceIds);\\n    } else {\\n      instances =\\n          createRestartForeachInstances(\\n              workflow,\\n              internalId,\\n              workflowVersionId,\\n              runProperties,\\n              foreachStepId,\\n              artifact,\\n              requests,\\n              instanceIds);\\n    }\\n    if (ObjectHelper.isCollectionEmptyOrNull(instances)) {\\n      return Optional.empty();\\n    }\\n    return instanceDao.runWorkflowInstances(workflow.getId(), instances, batchSize);\\n  }\\n\\n  private List<WorkflowInstance> createStartForeachInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      long workflowRunId,\\n      RunProperties runProperties,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    List<WorkflowInstance> instances =\\n        createWorkflowInstances(workflow, internalId, workflowVersionId, runProperties, requests);\\n\\n    Iterator<Long> instanceId = instanceIds.iterator();\\n    for (WorkflowInstance instance : instances) {\\n      instance.setWorkflowInstanceId(instanceId.next());\\n      instance.setWorkflowRunId(workflowRunId);\\n    }\",\n                \"newContent\": \"    }\\n    LOG.debug(\\n        \\\"Created {} of workflow instances for workflow id {} to start\\\",\\n        requests.size(),\\n        workflowId);\\n    return responses;\\n  }\\n\\n  /**\\n   * Run a batch of foreach workflow instances for a given workflow and version. The request list\\n   * has already been sized by insertBatchLimit in StepRuntimeProperties.Foreach. Note that batch\\n   * start only supports a fresh new run (run_id=1). Additionally, the instance ids have already\\n   * been decided to avoid race condition and ensure idempotency. It will bypass run strategy\\n   * manager as foreach manages its own inline workflow instances.\\n   *\\n   * @param batchSize the batch size for run job instance uuids within a run job event.\\n   * @return the status of start foreach workflow instances.\\n   */\\n  public Optional<Details> runForeachBatch(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds,\\n      int batchSize) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Optional.empty();\\n    }\\n    Checks.checkTrue(\\n        requests.size() == instanceIds.size(),\\n        \\\"Run request list size [%s] must match instance id list size [%s]\\\",\\n        requests.size(),\\n        instanceIds.size());\\n    List<WorkflowInstance> instances;\\n    if (artifact.isFreshRun()) {\\n      instances =\\n          createStartForeachInstances(\\n              new WorkflowInstanceCreationContext(\\n                  workflow,\\n                  internalId,\\n                  workflowVersionId,\\n                  runProperties),\\n              artifact.getForeachRunId(),\\n              requests,\\n              instanceIds);\\n    } else {\\n      instances =\\n          createRestartForeachInstances(\\n              new WorkflowInstanceCreationContext(\\n                  workflow,\\n                  internalId,\\n                  workflowVersionId,\\n                  runProperties),\\n              foreachStepId,\\n              artifact,\\n              requests,\\n              instanceIds);\\n    }\\n    if (ObjectHelper.isCollectionEmptyOrNull(instances)) {\\n      return Optional.empty();\\n    }\\n    return instanceDao.runWorkflowInstances(workflow.getId(), instances, batchSize);\\n  }\\n\\n  private List<WorkflowInstance> createStartForeachInstances(\\n      WorkflowInstanceCreationContext context,\\n      long workflowRunId,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    List<WorkflowInstance> instances =\\n        createWorkflowInstances(context, requests);\\n\\n    Iterator<Long> instanceId = instanceIds.iterator();\\n    for (WorkflowInstance instance : instances) {\\n      instance.setWorkflowInstanceId(instanceId.next());\\n      instance.setWorkflowRunId(workflowRunId);\\n    }\"\n            },\n            {\n                \"fromLine\": 254,\n                \"toLine\": 271,\n                \"oldContent\": \"\\n  private List<WorkflowInstance> createRestartForeachInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    long totalAncestorIterations =\\n        ObjectHelper.valueOrDefault(artifact.getAncestorIterationCount(), 0L);\\n    List<WorkflowInstance> instances = new ArrayList<>();\\n\\n    Iterator<Long> instanceIditerator = instanceIds.iterator();\\n    for (RunRequest request : requests) {\\n\",\n                \"newContent\": \"\\n  private List<WorkflowInstance> createRestartForeachInstances(\\n      WorkflowInstanceCreationContext context,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    long totalAncestorIterations =\\n        ObjectHelper.valueOrDefault(artifact.getAncestorIterationCount(), 0L);\\n    List<WorkflowInstance> instances = new ArrayList<>();\\n\\n    Iterator<Long> instanceIditerator = instanceIds.iterator();\\n    for (RunRequest request : requests) {\\n\"\n            },\n            {\n                \"fromLine\": 273,\n                \"toLine\": 297,\n                \"oldContent\": \"        RunRequest.RunRequestBuilder requestBuilder =\\n            request.toBuilder().currentPolicy(RunPolicy.RESTART_FROM_BEGINNING);\\n        if (!isRestartFromInlineRootMode(request, workflow)) {\\n          requestBuilder.restartConfig(null);\\n        }\\n        WorkflowInstance instance =\\n            workflowHelper.createWorkflowInstance(\\n                workflow.toBuilder().build(),\\n                internalId,\\n                workflowVersionId,\\n                runProperties,\\n                requestBuilder.build());\\n        instance.setWorkflowInstanceId(instanceId);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\\n      } else {\\n        WorkflowInstance instance =\\n            instanceDao.getLatestWorkflowInstanceRun(workflow.getId(), instanceId);\\n        if (!isRestartFromInlineRootMode(request, workflow)) {\\n          request.updateForDownstreamIfNeeded(foreachStepId, instance);\\n        }\\n        workflowHelper.updateWorkflowInstance(instance, request);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\",\n                \"newContent\": \"        RunRequest.RunRequestBuilder requestBuilder =\\n            request.toBuilder().currentPolicy(RunPolicy.RESTART_FROM_BEGINNING);\\n        if (!isRestartFromInlineRootMode(request, context.getWorkflow())) {\\n          requestBuilder.restartConfig(null);\\n        }\\n        WorkflowInstance instance =\\n            workflowHelper.createWorkflowInstance(\\n                context,\\n                requestBuilder.build());\\n        instance.setWorkflowInstanceId(instanceId);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\\n      } else {\\n        WorkflowInstance instance =\\n            instanceDao.getLatestWorkflowInstanceRun(context.getWorkflow().getId(), instanceId);\\n        if (!isRestartFromInlineRootMode(request, context.getWorkflow())) {\\n          request.updateForDownstreamIfNeeded(foreachStepId, instance);\\n        }\\n        workflowHelper.updateWorkflowInstance(instance, request);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\"\n            },\n            {\n                \"fromLine\": 328,\n                \"toLine\": 344,\n                \"oldContent\": \"\\n  private List<WorkflowInstance> createWorkflowInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      List<RunRequest> requests) {\\n    return requests.stream()\\n        .map(\\n            request ->\\n                workflowHelper.createWorkflowInstance(\\n                    workflow.toBuilder().build(),\\n                    internalId,\\n                    workflowVersionId,\\n                    runProperties,\\n                    request))\",\n                \"newContent\": \"\\n  private List<WorkflowInstance> createWorkflowInstances(\\n      WorkflowInstanceCreationContext context,\\n      List<RunRequest> requests) {\\n    return requests.stream()\\n        .map(\\n            request ->\\n                workflowHelper.createWorkflowInstance(\\n                    context,\\n                    request))\"\n            }\n        ]\n    },\n    \"extractedClasses\": {\n"