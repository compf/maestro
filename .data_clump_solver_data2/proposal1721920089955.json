"{\n    \"refactorings\": {\n        \"maestro-engine/src/main/java/com/netflix/maestro/engine/handlers/WorkflowActionHandler.java\": [\n            {\n                \"fromLine\": 49,\n                \"toLine\": 495,\n                \"oldContent\": \"import java.util.Collections;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util.Optional;\\nimport java.util.Set;\\nimport java.util.stream.Collectors;\\nimport javax.validation.constraints.NotNull;\\nimport lombok.AllArgsConstructor;\\nimport lombok.extern.slf4j.Slf4j;\\n\\n/** Workflow actor to implement all workflow actions. */\\n@Slf4j\\n@AllArgsConstructor\\npublic class WorkflowActionHandler {\\n  private final MaestroWorkflowDao workflowDao;\\n  private final MaestroWorkflowInstanceDao instanceDao;\\n  private final MaestroRunStrategyDao runStrategyDao;\\n  private final DryRunValidator dryRunValidator;\\n  private final WorkflowHelper workflowHelper;\\n\\n  /**\\n   * Start a workflow instance run. It first created a workflow instance in DB and then put it in a\\n   * queue to check its run strategy. After run strategy check, the workflow instance then gets\\n   * launched.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest`, or exact version id\\n   * @param runRequest run request with start configs and overrides\\n   * @return the response\\n   */\\n  public RunResponse start(\\n      @NotNull String workflowId, @NotNull String version, @NotNull RunRequest runRequest) {\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    validateRequest(version, definition, runRequest);\\n\\n    RunProperties runProperties =\\n        RunProperties.from(\\n            Checks.notNull(\\n                definition.getPropertiesSnapshot(),\\n                \\\"property snapshot cannot be null for workflow: \\\" + workflowId));\\n    // create and initiate a new instance with overrides and param evaluation\\n    WorkflowInstance instance =\\n        workflowHelper.createWorkflowInstance(\\n            definition.getWorkflow(),\\n            definition.getInternalId(),\\n            definition.getMetadata().getWorkflowVersionId(),\\n            runProperties,\\n            runRequest);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int ret = runStrategyDao.startWithRunStrategy(instance, runStrategy);\\n    RunResponse response = RunResponse.from(instance, ret);\\n    LOG.info(\\\"Created a workflow instance with response {}\\\", response);\\n    return response;\\n  }\\n\\n  private void validateRequest(\\n      String version, @NotNull WorkflowDefinition definition, @NotNull RunRequest request) {\\n    if (request.getInitiator() instanceof TriggerInitiator) {\\n      Checks.checkTrue(\\n          definition.getIsActive(),\\n          \\\"Triggered workflow definition for workflow [%s][%s] must be active.\\\",\\n          definition.getWorkflow().getId(),\\n          version);\\n      if (!((TriggerInitiator) request.getInitiator()).isValid(definition.getTriggerUuids())) {\\n        throw new MaestroResourceConflictException(\\n            \\\"Invalid trigger initiator due to mismatch trigger uuid.\\\");\\n      }\\n      if ((request.getInitiator().getType() == Initiator.Type.SIGNAL\\n              && ObjectHelper.valueOrDefault(\\n                  definition.getPropertiesSnapshot().getSignalTriggerDisabled(), Boolean.FALSE))\\n          || (request.getInitiator().getType() == Initiator.Type.TIME\\n              && ObjectHelper.valueOrDefault(\\n                  definition.getPropertiesSnapshot().getTimeTriggerDisabled(), Boolean.FALSE))) {\\n        throw new MaestroUnprocessableEntityException(\\n            \\\"Trigger type [%s] is disabled for the workflow [%s] in the workflow properties.\\\",\\n            request.getInitiator().getType(), definition.getWorkflow().getId());\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Start a batch of new workflow instance runs (i.e. with run_id = 1) asynchronous. It first\\n   * created workflow instances in DB and then send a job event to run strategy poller, which checks\\n   * and start queued workflow instances if possible. Note that request list size must fit into a\\n   * single DB transaction batch limit defined by {@link Constants#START_BATCH_LIMIT}. It will\\n   * handle the case with duplicate uuids.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version, `active`, `latest`, or exact version id\\n   * @param requests a list of start requests with start configs and overrides\\n   * @return the response\\n   */\\n  public List<RunResponse> startBatch(\\n      String workflowId, String version, List<RunRequest> requests) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Collections.emptyList();\\n    }\\n    Checks.checkTrue(\\n        requests.size() <= Constants.START_BATCH_LIMIT,\\n        \\\"The size of Requests is greater than the batch limit\\\");\\n    WorkflowDefinition definition = workflowDao.getWorkflowDefinition(workflowId, version);\\n\\n    // Fail the whole batch if any request is invalid\\n    requests.forEach(request -> validateRequest(version, definition, request));\\n\\n    RunProperties runProperties = RunProperties.from(definition.getPropertiesSnapshot());\\n\\n    List<WorkflowInstance> instances =\\n        createWorkflowInstances(\\n            definition.getWorkflow(),\\n            definition.getInternalId(),\\n            definition.getMetadata().getWorkflowVersionId(),\\n            runProperties,\\n            requests);\\n    RunStrategy runStrategy = definition.getRunStrategyOrDefault();\\n    int[] results = runStrategyDao.startBatchWithRunStrategy(workflowId, runStrategy, instances);\\n    List<RunResponse> responses = new ArrayList<>();\\n    int idx = 0;\\n    for (WorkflowInstance instance : instances) {\\n      responses.add(RunResponse.from(instance, results[idx]));\\n      idx++;\\n    }\\n    LOG.debug(\\n        \\\"Created {} of workflow instances for workflow id {} to start\\\",\\n        requests.size(),\\n        workflowId);\\n    return responses;\\n  }\\n\\n  /**\\n   * Run a batch of foreach workflow instances for a given workflow and version. The request list\\n   * has already been sized by insertBatchLimit in StepRuntimeProperties.Foreach. Note that batch\\n   * start only supports a fresh new run (run_id=1). Additionally, the instance ids have already\\n   * been decided to avoid race condition and ensure idempotency. It will bypass run strategy\\n   * manager as foreach manages its own inline workflow instances.\\n   *\\n   * @param batchSize the batch size for run job instance uuids within a run job event.\\n   * @return the status of start foreach workflow instances.\\n   */\\n  public Optional<Details> runForeachBatch(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds,\\n      int batchSize) {\\n    if (ObjectHelper.isCollectionEmptyOrNull(requests)) {\\n      return Optional.empty();\\n    }\\n    Checks.checkTrue(\\n        requests.size() == instanceIds.size(),\\n        \\\"Run request list size [%s] must match instance id list size [%s]\\\",\\n        requests.size(),\\n        instanceIds.size());\\n    List<WorkflowInstance> instances;\\n    if (artifact.isFreshRun()) {\\n      instances =\\n          createStartForeachInstances(\\n              workflow,\\n              internalId,\\n              workflowVersionId,\\n              artifact.getForeachRunId(),\\n              runProperties,\\n              requests,\\n              instanceIds);\\n    } else {\\n      instances =\\n          createRestartForeachInstances(\\n              workflow,\\n              internalId,\\n              workflowVersionId,\\n              runProperties,\\n              foreachStepId,\\n              artifact,\\n              requests,\\n              instanceIds);\\n    }\\n    if (ObjectHelper.isCollectionEmptyOrNull(instances)) {\\n      return Optional.empty();\\n    }\\n    return instanceDao.runWorkflowInstances(workflow.getId(), instances, batchSize);\\n  }\\n\\n  private List<WorkflowInstance> createStartForeachInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      long workflowRunId,\\n      RunProperties runProperties,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    List<WorkflowInstance> instances =\\n        createWorkflowInstances(workflow, internalId, workflowVersionId, runProperties, requests);\\n\\n    Iterator<Long> instanceId = instanceIds.iterator();\\n    for (WorkflowInstance instance : instances) {\\n      instance.setWorkflowInstanceId(instanceId.next());\\n      instance.setWorkflowRunId(workflowRunId);\\n    }\\n    return instances;\\n  }\\n\\n  private List<WorkflowInstance> createRestartForeachInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      String foreachStepId,\\n      ForeachArtifact artifact,\\n      List<RunRequest> requests,\\n      List<Long> instanceIds) {\\n    long totalAncestorIterations =\\n        ObjectHelper.valueOrDefault(artifact.getAncestorIterationCount(), 0L);\\n    List<WorkflowInstance> instances = new ArrayList<>();\\n\\n    Iterator<Long> instanceIditerator = instanceIds.iterator();\\n    for (RunRequest request : requests) {\\n\\n      long instanceId = instanceIditerator.next();\\n      if (instanceId > totalAncestorIterations) {\\n        RunRequest.RunRequestBuilder requestBuilder =\\n            request.toBuilder().currentPolicy(RunPolicy.RESTART_FROM_BEGINNING);\\n        if (!isRestartFromInlineRootMode(request, workflow)) {\\n          requestBuilder.restartConfig(null);\\n        }\\n        WorkflowInstance instance =\\n            workflowHelper.createWorkflowInstance(\\n                workflow.toBuilder().build(),\\n                internalId,\\n                workflowVersionId,\\n                runProperties,\\n                requestBuilder.build());\\n        instance.setWorkflowInstanceId(instanceId);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\\n      } else {\\n        WorkflowInstance instance =\\n            instanceDao.getLatestWorkflowInstanceRun(workflow.getId(), instanceId);\\n        if (!isRestartFromInlineRootMode(request, workflow)) {\\n          request.updateForDownstreamIfNeeded(foreachStepId, instance);\\n        }\\n        workflowHelper.updateWorkflowInstance(instance, request);\\n        instance.setWorkflowRunId(artifact.getForeachRunId());\\n        instances.add(instance);\\n      }\\n    }\\n    return instances;\\n  }\\n\\n  public Optional<Details> restartForeachInstance(\\n      RunRequest request, WorkflowInstance instance, String foreachStepId, long restartRunId) {\\n    request.updateForDownstreamIfNeeded(foreachStepId, instance);\\n    workflowHelper.updateWorkflowInstance(instance, request);\\n    instance.setWorkflowRunId(restartRunId);\\n    return instanceDao.runWorkflowInstances(\\n        instance.getWorkflowId(), Collections.singletonList(instance), 1);\\n  }\\n\\n  private boolean isRestartFromInlineRootMode(RunRequest request, Workflow workflow) {\\n    if (request.getInitiator().getType() == Initiator.Type.FOREACH\\n        && request.getRestartConfig() != null\\n        && request.getRestartConfig().getRestartPath() != null\\n        && request.getRestartConfig().getRestartPath().size() == 1\\n        && request.getRestartConfig().getRestartPath().get(0).getStepId() == null\\n        && !MapHelper.isEmptyOrNull(request.getRestartConfig().getStepRestartParams())) {\\n      UpstreamInitiator.Info info =\\n          ((ForeachInitiator) request.getInitiator()).getNonInlineParent();\\n      if (info.getWorkflowId().equals(request.getRestartWorkflowId())\\n          && info.getInstanceId() == request.getRestartInstanceId()) {\\n        Set<String> stepIds = request.getRestartConfig().getStepRestartParams().keySet();\\n        return workflow.getAllStepIds().stream().anyMatch(stepIds::contains);\\n      }\\n    }\\n    return false;\\n  }\\n\\n  private List<WorkflowInstance> createWorkflowInstances(\\n      Workflow workflow,\\n      Long internalId,\\n      long workflowVersionId,\\n      RunProperties runProperties,\\n      List<RunRequest> requests) {\\n    return requests.stream()\\n        .map(\\n            request ->\\n                workflowHelper.createWorkflowInstance(\\n                    workflow.toBuilder().build(),\\n                    internalId,\\n                    workflowVersionId,\\n                    runProperties,\\n                    request))\\n        .collect(Collectors.toList());\\n  }\\n\\n  /**\\n   * Validate a workflow definition.\\n   *\\n   * @param request workflow create request to validate\\n   */\\n  public void validate(WorkflowCreateRequest request, User caller) {\\n    LOG.debug(\\n        \\\"validating workflow [{}] for user [{}]\\\", request.getWorkflow().getId(), caller.getName());\\n    List<String> errors = new ArrayList<>();\\n    if (request.getWorkflow() == null) {\\n      errors.add(\\\"workflow cannot be null\\\");\\n    }\\n    // definition data will be checked by dryRunValidator\\n    try {\\n      dryRunValidator.validate(request.getWorkflow(), caller);\\n    } catch (MaestroDryRunException e) {\\n      errors.add(e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\\n    }\\n    if (!errors.isEmpty()) {\\n      throw new MaestroBadRequestException(errors, \\\"Invalid workflow create request\\\");\\n    }\\n  }\\n\\n  /**\\n   * Stop all current running workflow instances for the given workflow id.\\n   *\\n   * @param workflowId workflow id\\n   * @return the final timeline log message\\n   */\\n  public TimelineEvent stop(String workflowId, User caller) {\\n    return terminate(workflowId, Actions.WorkflowInstanceAction.STOP, caller);\\n  }\\n\\n  /**\\n   * Kill/fail all current running workflow instances for the given workflow id.\\n   *\\n   * @param workflowId workflow id\\n   * @return the final timeline log message\\n   */\\n  public TimelineEvent kill(String workflowId, User caller) {\\n    return terminate(workflowId, Actions.WorkflowInstanceAction.KILL, caller);\\n  }\\n\\n  private TimelineEvent terminate(\\n      String workflowId, Actions.WorkflowInstanceAction action, User caller) {\\n    String reason =\\n        String.format(\\n            \\\"All workflow instances of workflow id [%s] are terminated to status [%s] by the caller [%s]\\\",\\n            workflowId, action.getStatus(), caller.getName());\\n    int stopped = Constants.TERMINATE_BATCH_LIMIT;\\n    int stoppedQueued = 0;\\n    while (stopped == Constants.TERMINATE_BATCH_LIMIT) {\\n      stopped =\\n          instanceDao.terminateQueuedInstances(\\n              workflowId, Constants.TERMINATE_BATCH_LIMIT, action.getStatus(), reason);\\n      stoppedQueued += stopped;\\n    }\\n\\n    int stoppedRunning =\\n        instanceDao.terminateRunningInstances(\\n            workflowId, Constants.TERMINATE_BATCH_LIMIT, action, caller, reason);\\n\\n    LOG.info(\\n        \\\"Terminated [{}] queued instances and terminating [{}] running instances with reason [{}]\\\",\\n        stoppedQueued,\\n        stoppedRunning,\\n        reason);\\n\\n    return TimelineActionEvent.builder()\\n        .action(action)\\n        .author(caller)\\n        .message(\\n            \\\"Terminated [%s] queued instances and terminating [%s] running instances\\\",\\n            stoppedQueued, stoppedRunning)\\n        .reason(reason)\\n        .build();\\n  }\\n\\n  /**\\n   * Activate this workflow version.\\n   *\\n   * @param workflowId workflow id\\n   * @param version workflow version (i.e. active, latest, default, or exact version id)\\n   * @param caller the user making the call\\n   */\\n  public WorkflowActionResponse activate(String workflowId, String version, User caller) {\\n    Checks.notNull(\\n        caller, \\\"caller cannot be null to activate workflow [%s][%s]\\\", workflowId, version);\\n    WorkflowVersionUpdateJobEvent jobEvent =\\n        (WorkflowVersionUpdateJobEvent) workflowDao.activate(workflowId, version, caller);\\n    LOG.info(jobEvent.getLog());\\n    TimelineEvent event =\\n        TimelineActionEvent.builder()\\n            .action(Actions.WorkflowAction.ACTIVATE)\\n            .author(caller)\\n            .message(jobEvent.getLog())\\n            .build();\\n    return WorkflowActionResponse.from(workflowId, jobEvent.getCurrentActiveVersion(), event);\\n  }\\n\\n  /**\\n   * Deactivate the workflow with a provided workflow id.\\n   *\\n   * @param workflowId workflow id to deactivate\\n   * @param caller the caller\\n   * @return action response\\n   */\\n  public WorkflowActionResponse deactivate(String workflowId, User caller) {\\n    Checks.notNull(caller, \\\"caller cannot be null to deactivate workflow [%s]\\\", workflowId);\\n    String timeline = workflowDao.deactivate(workflowId, caller);\\n    LOG.info(timeline);\\n    TimelineEvent event =\\n        TimelineActionEvent.builder()\\n            .action(Actions.WorkflowAction.DEACTIVATE)\\n            .author(caller)\\n            .message(timeline)\\n            .build();\\n    return WorkflowActionResponse.from(workflowId, event);\\n  }\\n\\n  /**\\n   * Unblock the failed workflow instances with a provided workflow id.\\n   *\\n   * @param workflowId workflow id\\n   */\\n  public TimelineEvent unblock(String workflowId, User caller) {\\n    TimelineActionEvent.TimelineActionEventBuilder eventBuilder =\\n        TimelineActionEvent.builder().author(caller).reason(\\\"Unblock workflow [%s]\\\", workflowId);\\n    int totalUnblocked = 0;\\n    int unblocked = Constants.UNBLOCK_BATCH_SIZE;\\n    while (unblocked == Constants.UNBLOCK_BATCH_SIZE) {\\n      unblocked =\\n          instanceDao.tryUnblockFailedWorkflowInstances(\\n              workflowId, Constants.UNBLOCK_BATCH_SIZE, eventBuilder.build());\\n      totalUnblocked += unblocked;\\n    }\\n    workflowHelper.publishStartWorkflowEvent(workflowId, totalUnblocked > 0);\\n    return eventBuilder\\n        .message(\\\"Unblocked [%s] failed workflow instances.\\\", totalUnblocked)\\n        .build();\\n  }\\n}\\n\",\n                \"newContent\": \"import java.util.Collections;\\nimport java.util.Iterator;\\nimport java.util.List;\\nimport java.util"